name: Build and Release
on:
  push:
    branches:
      - master
jobs:
  build-linux:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential automake autoconf libtool python-dev-is-python3 ruby ruby-dev rubygems libreadline-dev gdb
          sudo gem install fpm
      - name: Build project
        working-directory: ./sources
        run: |
          ./autogen.sh
          ./configure CFLAGS="-g" --enable-pyjalali --prefix=/usr
          make
      - name: Verify build and debug if needed
        working-directory: ./sources
        run: |
          echo "Checking build outputs..."
          echo "=== Contents of src directory ==="
          ls -la src/
          
          echo "=== Checking for compiled binaries ==="
          find src/ -type f -executable -exec file {} \; | grep -E "(ELF|executable)"
          
          # Determine the actual binary to debug
          ACTUAL_JDATE=""
          if [ -f "src/.libs/jdate" ] && file "src/.libs/jdate" | grep -q "ELF"; then
            ACTUAL_JDATE="src/.libs/jdate"
            echo "Found actual binary: $ACTUAL_JDATE"
          elif [ -f "src/jdate" ] && file "src/jdate" | grep -q "ELF"; then
            ACTUAL_JDATE="src/jdate"
            echo "Found binary: $ACTUAL_JDATE"
          else
            echo "ERROR: No jdate binary found!"
            exit 1
          fi
          
          # File information
          echo "=== File information ==="
          file "$ACTUAL_JDATE"
          ls -la "$ACTUAL_JDATE"
          
          # Check library dependencies
          echo "=== Library dependencies ==="
          ldd "$ACTUAL_JDATE"
          
          # Look for the shared library
          echo "=== Looking for shared library ==="
          LIBJALALI_PATH=""
          if [ -f "src/.libs/libjalali.so.0" ]; then
            echo "Found libjalali.so.0 in src/.libs/"
            ls -la src/.libs/libjalali.so*
            LIBJALALI_PATH="src/.libs"
          elif [ -f "libjalali/.libs/libjalali.so.0" ]; then
            echo "Found libjalali.so.0 in libjalali/.libs/"
            ls -la libjalali/.libs/libjalali.so*
            LIBJALALI_PATH="libjalali/.libs"
          elif [ -f "libjalali/.libs/libjalali.so.0.0.5" ]; then
            echo "Found libjalali.so.0.0.5 in libjalali/.libs/"
            ls -la libjalali/.libs/libjalali.so*
            # Create a symlink if needed
            cd libjalali/.libs
            if [ ! -f "libjalali.so.0" ] && [ -f "libjalali.so.0.0.5" ]; then
              echo "Creating symlink libjalali.so.0 -> libjalali.so.0.0.5"
              ln -sf libjalali.so.0.0.5 libjalali.so.0
            fi
            cd ../../
            LIBJALALI_PATH="libjalali/.libs"
          else
            echo "ERROR: libjalali.so.0 not found!"
            find . -name "libjalali.so*" -type f
            exit 1
          fi
          
          # Set library path for execution
          export LD_LIBRARY_PATH="$LIBJALALI_PATH:$LD_LIBRARY_PATH"
          echo "Set LD_LIBRARY_PATH to: $LD_LIBRARY_PATH"
          
          # Test execution first
          echo "=== Testing execution ==="
          export PATH="$LIBJALALI_PATH:$PATH"
          if timeout 10s "$ACTUAL_JDATE" --version >/dev/null 2>&1; then
            echo "jdate execution successful"
          else
            echo "jdate execution failed or crashed"
          fi
          
          # Always run GDB for debugging (even if execution was successful)
          echo "=== Running GDB for debugging ==="
          gdb -batch \
              -ex "set confirm off" \
              -ex "set environment LD_LIBRARY_PATH=$LIBJALALI_PATH:$LD_LIBRARY_PATH" \
              -ex "handle SIGSEGV stop print" \
              -ex "run" \
              -ex "bt full" \
              -ex "info registers" \
              -ex "thread apply all bt full" \
              -ex "quit" \
              --args "$ACTUAL_JDATE" 2>&1 | tee gdb_output.log
          
          echo "GDB output saved to gdb_output.log"
          
          # Check if GDB caught a segfault
          if grep -q "SIGSEGV\|Segmentation fault" gdb_output.log; then
            echo "SEGFAULT DETECTED - Check gdb_output.log for details"
            # Exit with error to indicate segfault occurred
            exit 1
          else
            echo "No segfault detected in GDB session"
          fi
      - name: Create staging directory
        run: mkdir -p staging
      - name: Install to staging directory
        working-directory: ./sources
        run: make install DESTDIR=$(pwd)/../staging prefix=/usr/local prefix=/usr/local
      - name: Get project version
        id: get_version
        run: echo "VERSION=$(grep AC_INIT sources/configure.ac | cut -d '[' -f 3 | cut -d ']' -f 1)" >> $GITHUB_ENV
      - name: Create post-install script
        run: |
          cat > post-install.sh << 'EOF'
          #!/bin/bash
          # Update library cache after installation
          ldconfig
          EOF
          chmod +x post-install.sh
      - name: Package with FPM (.deb)
        run: |
          fpm -s dir -t deb -n jcal -v ${{ env.VERSION }} \
              --prefix / \
              --deb-suggests "libreadline8" \
              --description "Jalali calendar utilities" \
              --url "https://github.com/yourusername/jcal" \
              --license "GPL" \
              --after-install post-install.sh \
              -C staging .
      - name: Package with FPM (.rpm)
        run: |
          fpm -s dir -t rpm -n jcal -v ${{ env.VERSION }} \
              --prefix / \
              --rpm-summary "Jalali calendar utilities" \
              --description "Jalali calendar utilities" \
              --url "https://github.com/yourusername/jcal" \
              --license "GPL" \
              -C staging .
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: linux-packages
          path: |
            *.deb
            *.rpm
            gdb_output.log
  build-macos:
    runs-on: macos-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Install dependencies
        run: |
          brew install automake autoconf libtool gdb
          python -m pip install --upgrade pip
          pip install setuptools
      - name: Build project
        working-directory: ./sources
        run: |
          ./autogen.sh
          ./configure CFLAGS="-g" --enable-pyjalali
          make
      - name: Verify build and debug if needed
        working-directory: ./sources
        run: |
          echo "Checking build outputs..."
          echo "=== Contents of src directory ==="
          ls -la src/
          
          # Determine the actual binary to debug
          ACTUAL_JDATE=""
          if [ -f "src/.libs/jdate" ] && file "src/.libs/jdate" | grep -q "Mach-O"; then
            ACTUAL_JDATE="src/.libs/jdate"
            echo "Found actual binary: $ACTUAL_JDATE"
          elif [ -f "src/jdate" ] && file "src/jdate" | grep -q "Mach-O"; then
            ACTUAL_JDATE="src/jdate"
            echo "Found binary: $ACTUAL_JDATE"
          else
            echo "ERROR: No jdate binary found!"
            exit 1
          fi
          
          # File information
          echo "=== File information ==="
          file "$ACTUAL_JDATE"
          ls -la "$ACTUAL_JDATE"
          
          # Check library dependencies
          echo "=== Library dependencies ==="
          otool -L "$ACTUAL_JDATE"
          
          # Look for the shared library
          echo "=== Looking for shared library ==="
          LIBJALALI_PATH=""
          if [ -f "src/.libs/libjalali.0.dylib" ]; then
            echo "Found libjalali.0.dylib in src/.libs/"
            ls -la src/.libs/libjalali*.dylib
            LIBJALALI_PATH="src/.libs"
          elif [ -f "libjalali/.libs/libjalali.0.dylib" ]; then
            echo "Found libjalali.0.dylib in libjalali/.libs/"
            ls -la libjalali/.libs/libjalali*.dylib
            LIBJALALI_PATH="libjalali/.libs"
          elif [ -f "libjalali/.libs/libjalali.0.0.5.dylib" ]; then
            echo "Found libjalali.0.0.5.dylib in libjalali/.libs/"
            ls -la libjalali/.libs/libjalali*.dylib
            # Create a symlink if needed
            cd libjalali/.libs
            if [ ! -f "libjalali.0.dylib" ] && [ -f "libjalali.0.0.5.dylib" ]; then
              echo "Creating symlink libjalali.0.dylib -> libjalali.0.0.5.dylib"
              ln -sf libjalali.0.0.5.dylib libjalali.0.dylib
            fi
            cd ../../
            LIBJALALI_PATH="libjalali/.libs"
          else
            echo "ERROR: libjalali.0.dylib not found!"
            find . -name "libjalali*.dylib" -type f
            exit 1
          fi
          
          # Set library path for execution
          export DYLD_LIBRARY_PATH="$LIBJALALI_PATH:$DYLD_LIBRARY_PATH"
          echo "Set DYLD_LIBRARY_PATH to: $DYLD_LIBRARY_PATH"
          
          # Test execution first
          echo "=== Testing execution ==="
          if timeout 10s "$ACTUAL_JDATE" --version >/dev/null 2>&1; then
            echo "jdate execution successful"
          else
            echo "jdate execution failed or crashed"
          fi
          
          # Always run LLDB for debugging (even if execution was successful)
          echo "=== Running LLDB for debugging ==="
          lldb -o "settings set target.env-vars DYLD_LIBRARY_PATH=$LIBJALALI_PATH:$DYLD_LIBRARY_PATH" \
               -o "process handle -s false SIGSEGV" \
               -o "run" \
               -o "bt all" \
               -o "register read" \
               -o "image list" \
               -o "quit" \
               -- "$ACTUAL_JDATE" 2>&1 | tee lldb_output.log
          
          echo "LLDB output saved to lldb_output.log"
          
          # Check if LLDB caught a crash
          if grep -q "EXC_BAD_ACCESS\|SIGSEGV\|crash" lldb_output.log; then
            echo "CRASH DETECTED - Check lldb_output.log for details"
            # Exit with error to indicate crash occurred
            exit 1
          else
            echo "No crash detected in LLDB session"
          fi
      - name: Create staging directory
        run: mkdir -p staging
      - name: Install to staging directory
        working-directory: ./sources
        run: make install DESTDIR=$(pwd)/../staging
      - name: Get project version
        run: echo "VERSION=$(grep AC_INIT sources/configure.ac | cut -d '[' -f 3 | cut -d ']' -f 1)" >> $GITHUB_ENV
      - name: Create tarball
        run: |
          tar -czvf jcal-${{ env.VERSION }}-macos.tar.gz -C staging .
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: macos-package
          path: |
            jcal-${{ env.VERSION }}-macos.tar.gz
            lldb_output.log
  build-windows:
    runs-on: windows-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up MSYS2
        uses: msys2/setup-msys2@v2
        with:
          msystem: MINGW64
          update: true
          install: >-
            make
            mingw-w64-x86_64-toolchain
            autotools
            mingw-w64-x86_64-gdb
      - name: Build project
        shell: msys2 {0}
        working-directory: ./sources
        run: |
          ./autogen.sh
          ./configure CFLAGS="-g" --prefix=/mingw64
          make
      - name: Verify build and debug if needed
        shell: msys2 {0}
        working-directory: ./sources
        run: |
          echo "Checking build outputs..."
          echo "=== Contents of src directory ==="
          ls -la src/
          
          # Determine the actual binary to debug
          ACTUAL_JDATE=""
          if [ -f "src/.libs/jdate.exe" ] && file "src/.libs/jdate.exe" | grep -q "PE32"; then
            ACTUAL_JDATE="src/.libs/jdate.exe"
            echo "Found actual binary: $ACTUAL_JDATE"
          elif [ -f "src/jdate.exe" ] && file "src/jdate.exe" | grep -q "PE32"; then
            ACTUAL_JDATE="src/jdate.exe"
            echo "Found binary: $ACTUAL_JDATE"
          else
            echo "ERROR: No jdate.exe binary found!"
            exit 1
          fi
          
          # File information
          echo "=== File information ==="
          file "$ACTUAL_JDATE"
          ls -la "$ACTUAL_JDATE"
          
          # Check library dependencies
          echo "=== Library dependencies ==="
          ldd "$ACTUAL_JDATE" || objdump -p "$ACTUAL_JDATE" | grep "DLL Name"
          
          # Look for the shared library
          echo "=== Looking for shared library ==="
          LIBJALALI_PATH=""
          if [ -f "src/.libs/libjalali-0.dll" ]; then
            echo "Found libjalali-0.dll in src/.libs/"
            ls -la src/.libs/libjalali*.dll
            LIBJALALI_PATH="src/.libs"
          elif [ -f "libjalali/.libs/libjalali-0.dll" ]; then
            echo "Found libjalali-0.dll in libjalali/.libs/"
            ls -la libjalali/.libs/libjalali*.dll
            LIBJALALI_PATH="libjalali/.libs"
          elif [ -f "libjalali/.libs/libjalali-0-5.dll" ]; then
            echo "Found libjalali-0-5.dll in libjalali/.libs/"
            ls -la libjalali/.libs/libjalali*.dll
            # Create a symlink if needed
            cd libjalali/.libs
            if [ ! -f "libjalali-0.dll" ] && [ -f "libjalali-0-5.dll" ]; then
              echo "Creating symlink libjalali-0.dll -> libjalali-0-5.dll"
              ln -sf libjalali-0-5.dll libjalali-0.dll
            fi
            cd ../../
            LIBJALALI_PATH="libjalali/.libs"
          else
            echo "ERROR: libjalali-0.dll not found!"
            find . -name "libjalali*.dll" -type f
            exit 1
          fi
          
          # Add library path to PATH for execution
          export PATH="$LIBJALALI_PATH:$PATH"
          echo "Added $LIBJALALI_PATH to PATH"
          
          # Test execution first
          echo "=== Testing execution ==="
          if timeout 10s "$ACTUAL_JDATE" --version >/dev/null 2>&1; then
            echo "jdate execution successful"
          else
            echo "jdate execution failed or crashed"
          fi

          # Always run GDB for debugging (even if execution was successful)
          echo "=== Running GDB for debugging ==="
          gdb -batch \
              -ex "set confirm off" \
              -ex "set environment PATH=$LIBJALALI_PATH:$PATH" \
              -ex "handle SIGSEGV stop print" \
              -ex "run" \
              -ex "bt full" \
              -ex "info registers" \
              -ex "thread apply all bt full" \
              -ex "quit" \
              --args "$ACTUAL_JDATE" 2>&1 | tee gdb_output.log
              
          echo "GDB output saved to gdb_output.log"
          
          # Check if GDB caught a segfault
          if grep -q "SIGSEGV\|Segmentation fault" gdb_output.log; then
            echo "SEGFAULT DETECTED - Check gdb_output.log for details"
            # Exit with error to indicate segfault occurred
            exit 1
          else
            echo "No segfault detected in GDB session"
          fi
      - name: Create staging directory
        shell: msys2 {0}
        run: mkdir -p staging
      - name: Install to staging directory
        shell: msys2 {0}
        working-directory: ./sources
        run: make install DESTDIR=$(pwd)/../staging prefix=/mingw64
      - name: Get project version
        shell: bash
        run: echo "VERSION=$(grep AC_INIT sources/configure.ac | cut -d '[' -f 3 | cut -d ']' -f 1)" >> $GITHUB_ENV
      - name: Install WiX Toolset
        run: dotnet tool install --global wix
      - name: Create main WiX source file
        shell: pwsh
        run: |
          @"
          <Wix xmlns="http://wixtoolset.org/schemas/v4/wxs">
            <Package Name="jcal" Manufacturer="jcal" Version="${{ env.VERSION }}" UpgradeCode="8c1c9b2f-2e3a-4f1a-9e8a-8f0e1d2c2b3f">
              <Media Id="1" Cabinet="cab1.cab" EmbedCab="yes" />
              <MajorUpgrade DowngradeErrorMessage="A newer version of [ProductName] is already installed." />
              <Feature Id="Main">
                <ComponentGroupRef Id="ProductComponents" />
                <ComponentRef Id="Path" />
              </Feature>
              <StandardDirectory Id="ProgramFiles6432Folder">
                <Directory Id="INSTALLFOLDER" Name="jcal" />
              </StandardDirectory>
            </Package>
            <Fragment>
              <DirectoryRef Id="INSTALLFOLDER">
                <Component Id="Path" Guid="12345678-1234-1234-1234-123456789013">
                  <Environment Id="PATH" Name="PATH" Value="[INSTALLFOLDER]" Permanent="no" Part="last" Action="set" System="yes" />
                </Component>
              </DirectoryRef>
            </Fragment>
          </Wix>
          "@ | Out-File -FilePath "main.wxs" -Encoding "utf8"
      - name: Add .dotnet/tools to path
        run: echo "$HOME/.dotnet/tools" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
      - name: Harvest files with heat
        working-directory: staging/mingw64
        run: heat.exe dir . -ag -o ../../files.wxs -cg ProductComponents -dr INSTALLFOLDER
      - name: Fix WiX namespace
        shell: pwsh
        run: (Get-Content files.wxs) -replace 'http://schemas.microsoft.com/wix/2006/wi', 'http://wixtoolset.org/schemas/v4/wxs' | Set-Content files.wxs
      - name: Build MSI installer
        working-directory: staging/mingw64
        run: wix build -o ../../jcal-${{ env.VERSION }}.msi -b . ../../main.wxs ../../files.wxs
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: windows-package
          path: |
            jcal-${{ env.VERSION }}.msi
            gdb_output.log
  release:
    runs-on: ubuntu-latest
    needs: [build-linux, build-macos, build-windows]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Generate tag name
        id: tag
        run: echo "TAG_NAME=build-$(git rev-parse --short HEAD)" >> $GITHUB_ENV
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
      - name: List downloaded files
        run: ls -R artifacts
      - name: Upload Release Assets
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ env.TAG_NAME }}
          files: |
            artifacts/linux-packages/*
            artifacts/macos-package/*
            artifacts/windows-package/*
